<p align="center">
  <img src="png/banner.png"/>
</p>
<p align="center">
  <!-- Web-site -->
  <a href="https://sentient.xyz" target="_blank" style="margin: 2px;">
    <img alt="Homepage" src="https://img.shields.io/badge/Website-Sentient.xyz-%23FD698D.svg?style=for-the-badge&logo=data:image/webp;base64,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"/>
  </a>
  <!-- Github Repo Info -->
    <!-- Release -->
    <a href="https://github.com/sentient-agi/sentient-enclaves-framework/releases">
        <img alt="GitHub release" src="https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Fapi.github.com%2Frepos%2Fsentient-agi%2Fsentient-enclaves-framework%2Ftags&query=%24.0.name&style=for-the-badge&label=Release&color=darkgreen">
    </a>
    <!-- status as beta -->
    <a>
        <img alt="GitHub release" src="https://img.shields.io/badge/Release_Status-Beta-orange.svg?style=for-the-badge">
    </a>
    <!-- Rust Toolchain version -->
    <a href="./rust-toolchain">
        <img alt="Rust Toolchain" src="https://img.shields.io/badge/dynamic/toml?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsentient-agi%2Fsentient-enclaves-framework%2Fmain%2Frust-toolchain&query=%24.toolchain.channel&prefix=1.91%20&style=for-the-badge&label=Rust%20Toolchain&color=darkviolet">
    </a>
    <!-- License -->
    <a href="./LICENSE-APACHE">
        <img alt="License" src="https://img.shields.io/badge/License-Apache_2.0-blue.svg?style=for-the-badge">
    </a>
</p>

# Sentient Enclaves Framework

> **Sentient Enclaves Framework** is an end‑to‑end framework for building **confidential AI & crypto applications** on hardware **Trusted Execution Environments (TEEs)** – currently targeting **AWS Nitro Enclaves**.

It gives you:

- A **secure local channel (SLC)** for talking to enclaves over `vsock`
- **Transparent forward & reverse VSock/TCP proxies** for networking
- A **remote attestation web server** running inside the enclave
- A **file system monitor** for unattended attestation of external data
- A **reproducible build system** for enclave images (EIFs)
- Several **reference applications**: inference server, model fingerprinting server, and an X/Twitter agent

You can think of it as: **"Docker‑like developer ergonomics, but for TEEs."**

---

## Table of Contents

- [Conceptual Overview](#conceptual-overview)
- [Supported Platforms & Requirements](#supported-platforms--requirements)
- [Repository Layout](#repository-layout)
- [Architecture & Components](#architecture--components)
  - [Pipeline SLC](#pipeline-slc)
  - [Transparent VSock Proxies (`pf-proxy`)](#transparent-vsock-proxies-pf-proxy)
  - [Remote Attestation Web Server (`ra-web-srv`)](#remote-attestation-web-server-ra-web-srv)
  - [File System Monitor (`fs-monitor`)](#file-system-monitor-fs-monitor)
  - [Reproducible Build System (`rbuilds`)](#reproducible-build-system-rbuilds)
  - [Enclave Init System (`enclave-init`)](#enclave-init-system-enclave-init)
  - [Cryptography Stack (WIP)](#cryptography-stack-wip)
  - [Reference Applications](#reference-applications)
- [Quick Start](#quick-start)
  - [1. Prepare a Nitro Enclaves Host](#1-prepare-a-nitro-enclaves-host)
  - [2. Clone the Repository](#2-clone-the-repository)
  - [3. Build the Framework Components](#3-build-the-framework-components)
  - [4. Build & Run a Reference Application](#4-build--run-a-reference-application)
- [Usage Guide](#usage-guide)
  - [Typical Workflow](#typical-workflow)
  - [Working with `rbuilds` in Practice](#working-with-rbuilds-in-practice)
  - [Managing Enclaves](#managing-enclaves)
- [Remote Attestation & Integrity](#remote-attestation--integrity)
  - [External Data Proofs](#external-data-proofs)
  - [EIF / PCR Verification](#eif--pcr-verification)
  - [Debug vs Non‑Debug Enclaves](#debug-vs-non-debug-enclaves)
- [CLI Reference](#cli-reference)
  - [`rbuilds.sh`](#rbuildssh)
  - [Nitro CLI (Host)](#nitro-cli-host)
  - [Pipeline, Proxies, RA Server & FS Monitor](#pipeline-proxies-ra-server--fs-monitor)
- [Reproducible Builds & CI Integration](#reproducible-builds--ci-integration)
- [Reference Applications in Detail](#reference-applications-in-detail)
- [Changelog (High Level)](#changelog-high-level)
- [Roadmap (High Level)](#roadmap-high-level)
- [Contributing & Development Notes](#contributing--development-notes)
- [License](#license)

---

## Conceptual Overview

**Trusted Execution Environments (TEEs)** – also known as confidential computing environments – are hardware‑backed isolated execution zones (encrypted memory regions). Code and data inside a TEE are protected from the host OS, hypervisor, and cloud operator. Nitro Enclaves, AMD SEV‑SNP, and Intel TDX are examples.

The **Sentient Enclaves Framework** focuses on:

- Running **AI / crypto workloads** in TEEs
- Giving enclaves **network access** in a controlled, attestable way
- Providing **reproducible enclave images** you can verify and audit
- Enabling **remote attestation** of both code and external data
- Making enclave interactions feel similar to working with **containers**

---

## Supported Platforms & Requirements

### Primary Platform

- **AWS Nitro Enclaves** on EC2
- EC2 instances with **Nitro Enclaves enabled** in instance configuration

### Host OS & Software

On the EC2 host:

- Linux distribution supported by Nitro Enclaves (e.g., Amazon Linux)
- **Docker** (used by the build system to construct EIF images)
- AWS Nitro Enclaves tools:
  - `nitro-cli`
  - Nitro Enclaves kernel modules enabled
- Standard tooling: `bash`, `time`, `tee`, `git`, etc.

### Hardware / Memory Sizing

Recommended guideline:

> **Host RAM** ≈ 2 × (**size of your application’s Docker image**),
> because the enclave’s initramfs and rootfs are derived from that container plus runtime memory for the enclave itself.

### Future / Planned Platforms

The framework is designed to be portable - there are work‑in‑progress support for other confidential VMs (CVMs), including those with **GPU TEE support** (e.g., for confidential AI accelerators), via new Enclave's Engine for host/VM provisioning and CVM Launcher for KVM/QEMU.

---

## Repository Layout

Top‑level structure (simplified):

```text
secure-enclaves-framework/
├── docs/              # Markdown docs & GitHub Pages sources
├── enclave-init/      # Enclave init system sources
├── fs-monitor/        # Filesystem monitor for unattended data attestation
├── pf-proxy/          # Transparent VSock/TCP proxies (forward & reverse)
├── pipeline/          # Pipeline SLC client/server (vsock control, remote commands execution, files and directories transfer)
├── ra-web-srv/        # Remote attestation web server running inside enclave
├── rbuilds/           # Reproducible enclave build system (rbuilds.sh, Dockerfiles)
├── reference_apps/    # Example applications built on top of the framework
│   ├── fingerprinting_server/
│   ├── inference_server/
│   └── X_Agent/
├── .bin/, .docker/, .linux/, .cargo/  # Build artifacts, configurations & tooling
├── Cargo.toml         # Rust workspace for core components
├── README.md          # (Unified README)
└── LICENSE-APACHE
```

The GitHub Pages docs for this project are served from:
- [https://sentient-agi.github.io/Sentient-Enclaves-Framework/](https://sentient-agi.github.io/Sentient-Enclaves-Framework/)
- [https://andrcmdr.github.io/secure-enclaves-framework/](https://andrcmdr.github.io/secure-enclaves-framework/)

---

## Architecture & Components

### Pipeline SLC

**Pipeline SLC** is a **VSock secure local channel (SLC)** protocol implemented as a client–server pair (host side + enclave side). It provides:

- Remote execution of **shell commands inside the enclave**
- **Bidirectional file and directory transfers** to/from the enclave’s filesystem
- A **binary protocol over `vsock`**, designed for low overhead
- UX similar to `docker exec` / `docker cp` but for enclaves

Pipeline is the backbone for:

- Bootstrapping applications inside the enclave
- Uploading models / datasets / configuration
- Retrieving logs or result artifacts when reverse proxies are not enabled

Encryption support (WIP):

- Strong **P2P encryption** and **proxy re‑encryption (PRE)** between:
  - Host ↔ enclave
  - Enclave ↔ S3 (or other storage)
- Buffer‑level encryption for SLC traffic and content‑level encryption tools for data at rest / in transit
- Keys intended to be held in **KMS** (AWS KMS, Vault or distributed KMS) and optionally in local TPM on the EC2 host

---

### Transparent VSock Proxies (`pf-proxy`)

**`pf-proxy`** is a set of **transparent VSock proxies** that give enclaves a **full TCP/IP networking stack** in a controlled way.

Capabilities:

- **Outbound networking (forward proxy)** – enclave apps open outbound TCP connections (HTTP(S), gRPC, DB, etc.) via the proxy
- **Inbound networking (reverse proxy)** – expose enclave services (e.g., HTTPS API) to the outside world while keeping them confined in the enclave
- Transparent port forwarding and **NAT**:
  - Retrieves the **original destination address** from the TCP stream
  - Supports **many‑to‑many** listener schemes and **full‑cone NAT** style behaviour
- Strong reliance on Linux **Netfilter** and custom reproducible **Linux kernel** builds for enclave networking support

Use cases:

- Giving an inference server in the enclave access to S3 / external APIs
- Publishing a confidential web service directly from within the enclave (as for in-house attestation web server, which is part of this framework)

---

### Remote Attestation Web Server (`ra-web-srv`)

**`ra-web-srv`** runs *inside the enclave* and exposes a **HTTPS API** for remote attestation.

It supports two major attestation flows:

1. **External data integrity proofs**
2. **EIF / PCR attestation of the running enclave**

Key ideas:

- Runs on a TLS endpoint (e.g., `https://127.0.0.1:8443`) inside the enclave
- Can be reached either via:
  - Reverse proxy in `pf-proxy` (if **networking enabled** via `--network` in builds), or
  - Via Pipeline SLC, using `vsock` port forwarding (making requests from inside the enclave)

Endpoints (simplified):

- **Generate proof for file content**

  ```bash
  curl -k -X POST \
    -H 'Content-Type: application/json' \
    -d '{ "path": "/path/to/file" }' \
    https://127.0.0.1:8443/generate
  ```

- **Get generated proof**

  ```bash
  curl -k \
    "https://127.0.0.1:8443/proof/?path=/path/to/file"
  ```

- **Get attestation document (with PCRs) related to a file**

  ```bash
  curl -k \
    "https://127.0.0.1:8443/doc/?path=/path/to/file/&view=json_hex"
  ```

The RA server returns cryptographic hashes and VRF proofs that can be validated off‑enclave.

---

### File System Monitor (`fs-monitor`)

**`fs-monitor`** is designed as a **real‑time file system watcher** for the enclave’s ramdisk, with the files integrity hashing as for CoW filesystem. It:

- Uses Linux **`inotify`** to track file & directory changes inside the enclave FS
- Computes per‑file hashes, effectively emulating a **copy‑on‑write layer** for runtime FS changes
- Acts as a **data provider** (providing unattended files hashing) for the RA web server:
  - Automatically creates / updates attestation entries for new or modified files
- Enables **unattended, unconditional attestation** of *all* external data that appears inside the enclave runtime filesystem

Integration:

- Tight integration with `ra-web-srv` (through NATS based service bus in enclave)
- Attestation documents are stored/cached (hot cache in memory + cold DB storage using **NATS** KV storage)

---

### Reproducible Build System (`rbuilds`)

The **`rbuilds`** component is a **reproducible build system** for constructing enclave images (EIFs) from Dockerfiles.

Features:

- Build all enclave components (kernel, init, rootfs, apps, Pipeline SLC, proxies, RA server, FS monitor, NATS, etc.) in a deterministic way
- Produce **reproducible EIFs** with stable hashes
- Rebuilds:
  - A custom **Linux kernel** with enclave networking stack
  - The enclave **init system**
  - Application containers exported into initramfs / rootfs
- Operates purely with standard Unix/Linux tooling + Docker
- Designed to integrate with **CI/CD** (GitHub Actions, self‑hosted CI, etc.)

You drive it via `rbuilds.sh` (shell script) which acts as a meta‑orchestrator over Docker builds and Nitro CLI steps.

---

### Enclave Init System (`enclave-init`)

The **`enclave-init`** component is the **init process** that runs as PID 1 inside the enclave.

Responsibilities:

- Bootstraps the enclave environment from the exported rootfs
- Starts:
  - Pipeline SLC server
  - Proxies
  - RA web server
  - FS Monitor
  - NATS DB and MQ (service bus)
  - User application processes
- Handles:
  - initial file systems mount
  - system signals for processes
  - processes and services management (inspired by `systemd` and `SysVInit`)
  - uses `initctl` tool and control protocol through local Unix domain socket and/or VSock remotely from host, for processes and services management
  - enclave state (system status and health check, reload configurations and services files on the fly, reboot, shutdown), graceful shutdown of enclave
  - Nitro Secure Kernel Module (NSM device) loading
  - interaction with Nitro/KVM hypervisor (enclave boot readiness, liveness and health checks)

For now Enclaves Framework includes an updated init system fully rewritten in **Rust** for stronger safety guarantees.
New Enclave's Init System integration into reproducible builds system (`rbuilds,sh`) included in the Roadmap.

---

### Cryptography Stack (WIP)

The **cryptography stack** (see `cryptography/` folder when present) is responsible for:

- SLC buffer‑level encryption for the Pipeline Secure Local Channel (SLC) protocol
- Content‑level encryption / decryption between enclave, host, and S3
- **Multi‑hop proxy re‑encryption (PRE)** for privacy‑preserving data flows across multiple participants / enclaves / services
- Integration with **KMS** and (optionally) local TPMs on the host

Several parts that are marked as **WIP** in the Roadmap will be delivered soon; some functionality may be experimental or disabled in the current main branch.

---

### Reference Applications

Under `reference_apps/` you’ll find example applications built on top of the framework:

- **`fingerprinting_server`** – a model fingerprinting (rights protection with DRM, Digital Rights Management, injection into model layers) service built with using the OML (Open Monetizable Loyal) principle for fingerprinting
- **`inference_server`** – a local model inference server running inside an enclave
- **`X_Agent`** – a chat‑style agent that interacts with X (Twitter) users, demonstrating:
  - Networking via proxies
  - Remote attestation flows
  - File integrity proofs

Each app contains:

- `<app>.dockerfile` – Dockerfile template used by `rbuilds` to construct the enclave image for that app
- `TEE_rbuilds_setup.md` – the **current** build & run guide for that app (using `rbuilds`)
- `TEE_setup.md` – **legacy** setup guide (pre‑`rbuilds` build system); kept for reference

---

## Quick Start

### 1. Prepare a Nitro Enclaves Host

1. Launch an **EC2 instance** with **Nitro Enclaves** enabled (AMI + instance type that support it)
2. Install required tooling on the host:
   - `docker`
   - `nitro-cli`
   - `git`
3. Ensure your IAM / instance profile allows access to any services you plan to use (S3, KMS, etc).

---

### 2. Clone the Repository

```bash
git clone https://github.com/sentient-agi/Sentient-Enclaves-Framework.git
cd Sentient-Enclaves-Framework
```

---

### 3. Build the Framework Components

The **recommended** way is via the `rbuilds` system.

From the project root:

```bash
cd rbuilds
# Example: run an internal command with TTY + debug logging
./rbuilds.sh --tty --debug --cmd make_all
```

Typical options you’ll use:

- `--tty` – create a TTY for Docker and bash (output is wired via FD 3)
- `--debug` – verbose logging and (for some commands) debug enclave mode
- `--dockerfile <path>` – choose which Dockerfile template to build from
- `--network` – include networking/proxy components in the EIF
- `--init-c` – use the C‑based init system variant
- `--cmd <name>` – run a specific internal command, such as:
  - `make_all`
  - `make_kernel`
  - `make_apps`
  - `make_init`
  - `make_eif`
  - `make_enclave`

The first successful `make_all` will:

- Build / rebuild custom kernel + init
- Build Enclaves Framework components (`make_apps`)
- Build your app container
- Export rootfs / initramfs
- Produce an **EIF** (Enclave Image File) ready to run with Nitro Enclaves
- Prepare Nitro Enclaves run-time configuration and run the enclave from the current EIF enclave image file

---

### 4. Build & Run a Reference Application

Every reference app follows a similar pattern and has its own `TEE_rbuilds_setup.md` with exact commands. High‑level steps:

1. **Pick an app**, e.g.:

   ```bash
   cd reference_apps/inference_server
   ```

2. **Inspect the app Dockerfile**:

   ```bash
   ls *.dockerfile
   ```

3. **Follow the app’s `TEE_rbuilds_setup.md`**, which typically instructs you to call `rbuilds.sh` with:
   - `--dockerfile` pointing to the app’s Dockerfile
   - `--network` if the app needs external connectivity
   - `--cmd make_all` or equivalent

4. **Run the enclave** using `rbuilds` convenience commands, for example:

   ```bash
   cd rbuilds
   ./rbuilds.sh --tty --debug --network --init-c --cmd run_eif_image
   ```

5. (Optional) **Attach console** and interact with the running enclave:

   ```bash
   ./rbuilds.sh --tty --debug --network --init-c --cmd attach_console_to_enclave
   ```

6. Use **Pipeline** or the proxies to talk to your app, depending on whether it is exposed via network or only locally inside the enclave.

---

## Usage Guide

### Typical Workflow

A common developer flow looks like this:

1. **Design your enclave app** as a Docker container
   - Start from an Amazon Linux base or whatever your `rbuilds` Dockerfiles use
   - Bundle your application, models, and runtime dependencies

2. **Register it with the framework**
   - Place your app Dockerfile under `reference_apps/<your_app>/`
   - Add a `TEE_rbuilds_setup.md` describing the exact `rbuilds.sh` commands to build & run it

3. **Build enclave image via `rbuilds`**
   - Build the kernel, init, enclaves framework components and your app image in a reproducible way
   - Produce an EIF with deterministic hash

4. **Run the enclave**
   - Use `rbuilds` commands like `run_eif_image` or `run_eif_image_debugmode_cli`
   - Attach console if needed

5. **Connect via Pipeline**
   - Copy data in/out
   - Execute commands inside the enclave

6. **Enable networking with `pf-proxy` (optional but common)**
   - Forward outbound connections (e.g., to S3 or external APIs)
   - Expose inbound ports (for inference APIs, RA HTTP endpoints, etc.)

7. **Set up remote attestation**
   - Start `ra-web-srv` inside enclave
   - Use it (plus `fs-monitor`) to attest your app, data, and runtime state

8. **Integrate with CI/CD**
   - Use `rbuilds` commands in GitHub Actions or other CI to produce EIFs
   - Publish image hashes and attestation metadata

---

### Working with `rbuilds` in Practice

`rbuilds.sh` has three main usage modes:

1. **Single command (CLI) mode**

   ```bash
   ./rbuilds.sh --tty --debug --cmd make_all
   ```

2. **Interactive shell mode (internal shell/REPL prompt)**

   ```bash
   ./rbuilds.sh
   # You’ll get an internal prompt where you can type:
   #   make_all
   #   run_eif_image
   #   list_enclaves
   #   drop_enclaves_all
   ```

3. **Automation command shell interface (commands as input sequence for `rbuilds.sh` script)**

   ```bash
   { echo "list_enclaves"; } | ./rbuilds.sh
   { echo "drop_enclave"; } | ./rbuilds.sh
   ```

There is also a special internal command `lsh` that lets you run local host shell commands via the same automation interface (i.e. one/any of the usage modes, intended for careful, advanced automation):

```bash
{ echo "lsh"; echo "ls -lah"; } | ./rbuilds.sh
```

Use the built‑in help for the most accurate, up‑to‑date options:

```bash
./rbuilds.sh --man
./rbuilds.sh --info
```

---

### Managing Enclaves

Common `rbuilds` internal commands (names taken from documentation; always double‑check with `--man` on your version):

- `make_kernel` – build custom kernel image
- `make_apps` – build framework components as application layers
- `make_init` – build enclave init
- `make_eif` – assemble EIF from built parts
- `make_all` / `make_enclave` – full build → EIF → ready to run

Enclave lifecycle:

- `run_eif_image_debugmode_cli` – run EIF in debug mode (console accessible; PCRs invalid for attestation)
- `run_eif_image` – run EIF in normal (non‑debug) mode
- `attach_console_to_enclave` – attach Nitro console to running enclave
- `list_enclaves` – list running enclaves
- `drop_enclave` – stop one enclave
- `drop_enclaves_all` – stop all enclaves managed by this setup

---

## Remote Attestation & Integrity

### External Data Proofs

To attest external data (e.g. models, datasets, configs) copied into the enclave, you use the RA web server:

1. **Generate a proof**

   ```bash
   curl -k -X POST \
     -H 'Content-Type: application/json' \
     -d '{ "path": "/path/to/file" }' \
     https://127.0.0.1:8443/generate
   ```

   - The RA server computes a hash and VRF proof (for hash) of the file in the enclave FS.
   - When calling via Pipeline instead of direct network, escape quotes per your shell’s needs.

2. **Retrieve proof**

   ```bash
   curl -k \
     "https://127.0.0.1:8443/proof/?path=/path/to/file"
   ```

3. **Verify off‑enclave**

   - Compute a local hash of what you believe is the correct file content.
   - Compare with the hash (and other evidence) coming from the enclave’s RA server.
   - If they match and you trust the RA endpoint (see EIF attestation below), you gain confidence that:
     - The data inside the enclave is exactly what you expect.
     - It hasn’t been tampered with post‑attestation.

---

### EIF / PCR Verification

To prove that the **right EIF image** is running, compare **PCR measurements** between:

1. **Runtime PCRs from inside enclave** (via RA web server):

   ```bash
   curl -k \
     "https://127.0.0.1:8443/doc/?path=/path/to/file/&view=json_hex"
   ```

2. **Reference PCRs from EIF on host**:

   ```bash
   nitro-cli describe-eif --eif-path /path/to/your/app.eif
   ```

The important PCRs are:

- **PCR0**: measurement of all data influencing runtime of code in EIF
  - Roughly `SHA384(Kernel | Cmdline | Ramdisk(init) | Ramdisk(1:))`
- **PCR1**: measurement of bootstrap + kernel
  - `SHA384(Kernel | Initramfs | Cmdline | Ramdisk(init))`
- **PCR2**: measurement of user application portion
  - `SHA384(Ramdisk(1:))`

If PCR0/1/2 from **runtime** (RA) match those from **`describe-eif`**, you have cryptographic proof that the expected EIF is running.

---

### Debug vs Non‑Debug Enclaves

Important security note:

- In **debug mode**, Nitro Enclaves run-time (and hypervisor) does **not** set PCRs (they show as all zeros).
  - Attestation is **not meaningful**.
- For **valid attestation**:
  - Run enclaves in **non‑debug** mode
  - Build EIFs using `rbuilds` steps that produce production‑grade images
  - Only then do PCRs reflect your actual image contents

---

## CLI Reference

> **Note:** Exact flags and subcommands may evolve; always check `--help`, `--info`, or project docs (README of each component) for your version. The summaries below are based on the current docs & repo structure.

### `rbuilds.sh`

Location:

- `rbuilds/rbuilds.sh` (invoked from the repo root: `cd rbuilds && ./rbuilds.sh`)

Common flags:

- `--tty`
  - Allocate TTY for Docker and shell processes
  - Requires redirecting FD 3 to STDOUT in some usage patterns (`3>&1`)
- `--debug`
  - Verbose logs; may enable debug enclave runs for some commands
- `--dockerfile <path>`
  - Select specific Dockerfile template (e.g. `./pipeline-slc-network-al2023.dockerfile`)
- `--network`
  - Build with network / proxy features enabled (forward & reverse)
- `--init-c`
  - Use C‑based init system variant
- `--cmd <internal_command>`
  - Run one of the framework’s internal orchestration commands (build stages, enclave lifecycle, etc.)
- `--man`, `--info`
  - Print manual / detailed info text for the current version

Typical commands (not exhaustive):

- Build stages:
  - `make_kernel`
  - `make_apps`
  - `make_init`
  - `make_eif`
  - `make_all` / `make_enclave`
- Enclave control:
  - `run_eif_image`
  - `run_eif_image_debugmode_cli`
  - `attach_console_to_enclave`
  - `list_enclaves`
  - `drop_enclave`
  - `drop_enclaves_all`
- Special shell:
  - `lsh` – local shell mode inside the automation interface (advanced)

---

### Nitro CLI (Host)

Nitro CLI is not part of this repo but is heavily used alongside it. Key commands in the docs:

- **Inspect EIF and PCRs**

  ```bash
  nitro-cli describe-eif --eif-path /path/to/app.eif
  ```

- **Start / terminate enclaves**

  `rbuilds` internal commands are wrap Nitro CLI commands like:

  ```bash
  nitro-cli run-enclave     # via rbuilds
  nitro-cli terminate-enclave
  nitro-cli describe-enclaves
  ```

(Always check `man nitro-cli` on the host for authoritative syntax.)

---

### Pipeline, Proxies, RA Server & FS Monitor

These binaries are part of the Rust (Cargo) workspace and built into your EIF; they also typically have their own `--help` usage.

- **Pipeline**
  - Provides a CLI to:
    - Connect host ↔ enclave over VSock
    - Execute commands inside the enclave
    - Upload / download files and directories
  - Usage pattern (conceptual):

    ```bash
    pipeline --enclave-id <id> \
             --vsock-port <port> \
             exec -- <command>
    ```

  - For details:

    ```bash
    pipeline --help
    ```

- **`pf-proxy`**
  - Multiple modes:
    - Forward proxy (outbound connections)
    - Reverse proxy (inbound connections)
    - Transparent port forwarding / NAT
  - Configured via CLI flags and/or config files (ports, vsock addresses, NAT rules).
  - For exact options:

    ```bash
    pf-proxy --help
    ```

- **`ra-web-srv`**
  - Runs inside enclave; CLI/config typically sets:
    - Listen address / port
    - TLS key/cert paths
    - NATS integration (URL, KV bucket)
    - Paths / sockets for FS monitor integration
    - NSM device enabling
    - VRF cipher suite and keys for it
  - RA service is normally started by `enclave-init` or `init`; for manual usage:

    ```bash
    ra-web-srv --help
    ```

- **`fs-monitor`**
  - Watches FS paths (e.g., `/models`, `/data`) and reports changes.
  - Configurable via CLI or configuration file (paths, ignore patterns, etc.)
  - For details:

    ```bash
    fs-monitor --help
    ```

Because these components are all Rust binaries in this repo, you can also build & run them individually using Cargo during development:

```bash
cargo build -p pipeline
cargo run -p pipeline -- --help
```

---

## Reproducible Builds & CI Integration

The framework’s **reproducible build system** is designed for CI pipelines and supply‑chain integrity:

- **Reproducible EIFs**:
  - Builds are deterministic so you can:
    - Rebuild an EIF from the same source & Dockerfile
    - Compare resulting hashes to verify integrity

- **CI integration**:
  - `rbuilds.sh` is scriptable and has an automation shell interface
  - You can run internal commands from GitHub Actions or other CI, e.g.:

    ```bash
    { echo "make_all"; } | ./rbuilds/rbuilds.sh
    ```

- **Release semantics** (from docs’ changelog):
  - `0.1.0` – Pipeline SLC protocol
  - `0.2.0` – Reproducible builds for EIF images
  - `0.3.0` – Forward proxies & networking stack
  - `0.4.0` – New updated reproducible build system
  - `0.5.0` – Reverse proxies (including transparent port‑to‑vsock)
  - `0.6.0` – Reference applications bundle (inference server, fine‑tuning / OML server, X agent)
  - `0.7.0` - RA Web Servcer and VRF proofs for file hashes (SHA3-512) crypto-scheme for authenticated integrity checks
  - `0.8.0` - FS monitor (ramdisk CoW hashing layer for integrity checks and attestation for external data)
  - `0.9.0` – New Enclave's Init System written in Rust

In CI, you would typically:

1. Check out repo
2. Run `rbuilds.sh` to produce EIFs
3. Store EIF plus its hash and build logs as artifacts
4. Optionally, spin up an enclave and use `ra-web-srv` from CI to produce attestation docs

---

## Reference Applications in Detail

> All apps live under `reference_apps/` and each has its own `TEE_rbuilds_setup.md` for precise steps.

### `fingerprinting_server`

- **Purpose:**
  Confidential **model fingerprinting** service that computes fingerprints based on the **OML** (Open Monetizable Loyal principle) fingerprinting library.
  A model fingerprinting (rights protection with DRM, Digital Rights Management, prompt injection into model layers) service built with using the OML (Open Monetizable Loyal) principle for fingerprinting.

- **Enclave value‑add:**
  - Fingerprinting logic, model weights, and input data all live inside a TEE.
  - Can be combined with RA to prove where/what model was used.

---

### `inference_server`

- **Purpose:**
  Generic **inference server** that runs local ML models inside an enclave.
  Suitable for building mid-size LLM and SLM models inferense for confidential agents and agentic setup environments.

- **Features (depending on branch / config):**
  - Serves HTTP / gRPC endpoints via reverse proxy
  - Pulls models or data from S3 via forward proxy (optional)

---

### `X_Agent`

- **Purpose:**
  Chat agent that interacts with **X (Twitter)** users, demonstrating real‑world external integrations.

- **Showcases:**
  - Using proxies for outbound social‑media API calls
  - Using RA + FS monitor to attest configuration, API keys (via KMS), and logs
  - EIF attestation walkthrough (in the X Agent docs section)

In all cases:

- Use the specific app’s `TEE_rbuilds_setup.md` as your source of truth for:
  - Which Dockerfile to build
  - Which `rbuilds` command sequence to use
  - How to expose the app (ports, proxies, etc.)

---

## Changelog (High Level)

From the docs’ summarized changelog:

- **0.1.0** – Pipeline SLC (secure local channel) protocol; host↔enclave file transfer and remote command exec; container‑like UX
- **0.2.0** – Reproducible builds framework for customized EIF images (“just use your app Dockerfile and build enclave”)
- **0.3.0** – Forward / transparent proxies and port‑forwarding for TCP/UDP (HTTP(S), DNS, etc.); full networking stack for enclave apps
- **0.4.0** – Updated reproducible build system for EIFs
- **0.5.0** – Reverse proxies, including transparent port‑to‑vsock, enabling confidential services hosted in enclaves
- **0.6.0** – Reference applications: inference server, fine‑tuning server (OML), X agent
- **0.7.0** – Web protocol for RA with VRF proofs, multi‑threaded runtime, hot cache + NATS DB KV storage, mass attestation doc production
- **0.8.0** – File system monitor (fs‑monitor) fully integrated for automatic attestation docs generation
- **0.9.0** – New Enclave's Init System written in Rust

(For exact version tagging, refer to GitHub releases.)

---

## Roadmap (High Level)

Planned / in‑progress items from the Roadmap docs:

- **0.10.0** – Cryptography stack for SLC buffer & content encryption
- **0.11.0** – KMS integration for key storage; potential TPM integration for local key storage
- **0.12.0** – Advanced logging & tracing for Pipeline and proxies (web‑RA already uses structured logging)
- **0.13.0** – Enclaves engine service with Docker‑like web API:
  - Provisioning EC2 / other instances
  - Building & deploying enclaves
  - Integrating with AWS SQS / MQ and CI
- **0.14.0** – CVM Launcher and Framework port to QEMU VMs with EIF support, qCOW image and PCI device attestation, FS monitoring for qCOW disks

All roadmap items are subject to change in order and versioning.

---

## Contributing & Development Notes

- The codebase is mostly **Rust** + **Shell**, with some **Docker**, **Python**, **C**, and **Nix**.

### Suggested Dev Setup

1. Install the Rust toolchain matching `rust-toolchain` in the repo.
2. Build the Rust workspace:

   ```bash
   cargo build --workspace
   ```

3. For working on individual components:

   ```bash
   cargo run -p pipeline -- --help
   cargo test -p pf-proxy
   ```

4. For build system changes, focus on `rbuilds/` and `.docker/`, `.linux/`, `.bin/` directories.

---

## License

This project is licensed under the **Apache 2.0 License**. See the [`LICENSE-APACHE`](LICENSE-APACHE) file for the details.

---

## Support

For issues, questions, or contributions, please refer to the project repository:

- **Issue Tracker**: [GitHub Issues](https://github.com/sentient-agi/Sentient-Enclaves-Framework/issues)
- **Discussions**: [GitHub Discussions](https://github.com/sentient-agi/Sentient-Enclaves-Framework/discussions)
- **Documentation**: [GitHub Wiki](https://github.com/sentient-agi/Sentient-Enclaves-Framework/wiki)
- **Email**: Sentient Enclaves Team <sentient-enclaves-team@sentient.xyz>

---

## Contributing

Contributions are welcome!

### Getting Started

Please follow these guidelines:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/feature-name`)
3. Make your changes
4. Add tests
5. Run tests: `cargo test`
6. Run lints: `cargo clippy`
7. Commit changes (`git commit -am 'Add feature'`)
8. Push to branch (`git push origin feature/feature-name`)
9. Submit a Pull Request

### Code Style

- Follow Rust naming conventions
- Use `rustfmt` for formatting
- Add documentation for public APIs and new features
- Include tests for new functionality

Please ensure:

- Code follows Rust style guidelines (rustfmt)
- All tests pass
- New features include documentation
- Security implications are considered

### Pull Request Guidelines

- Clear description of changes
- Link to related issues
- Include test coverage
- Update documentation as needed

---

